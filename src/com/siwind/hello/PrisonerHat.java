package com.siwind.hello;

import java.util.BitSet;

/**
 * Created by admin on 2015/12/21.
 *
 16个犯人，狱官让他们聚在一起，给每个人戴上一顶红色或蓝色的帽子。每个人都能看到另外15个人的帽子而看不见自己的帽子。
 已知他们每个人戴上红帽子和蓝帽子的概率均为1/2（注意：并非意味着恰有8顶红帽子）。
 随后，将16个犯人带到密室，分别审问。每一个犯人有两种选择：他可以猜自己头上帽子的颜色，也可以不猜。
 如果发生以下情况：16个犯人中至少有一个人选择了猜并且所有猜的人都猜对了自己头上帽子的颜色，
 16个犯人就可以全部被释放，否则就将他们全部处死。在给犯人们戴帽子之前，他们可以商讨方案，
 但在戴上帽子后不允许以任何方式作弊。请找到一种方案，使他们被释放的概率大于90%。
 */
public class PrisonerHat {

    public static void testHat(){
        int n = 16;
        Hat hat = new Hat(n);

        System.out.println("n="+n + ", freq="+hat.getXOR0Frequency());

    }
    public static void main(String[] args){
        //System.out.println("Hello,world!");
        testHat();
    }
}

/**
 *
 将16个人用二进制编号，并由此编上他们帽子的颜色，从0000到1111，然后在戴帽子时，
 每个人分别统计另15个人中戴红帽子和蓝帽子的号码总和，在求和时，做一种“不进位的二进制加法”，
 （即在某一位上，1+1=0，并且不进位，比如1011+1001=0010，其实本质就是“异或”操作）
 若算得红帽子的号码总和与自己的号码相同，就猜自己戴蓝帽子，若算得蓝帽子号码的总和与自己的号码相同，
 就猜自己戴红帽子，否则不猜。这样，他们存活的概率可以达到15/16，也即93.75%。
 下面来证明这一点：在“不进位的二进制加法”下，16顶帽子的总和为0000，于是红帽子号码之和等于蓝帽子的号码之和。

 下面分 "红帽子号码之和=蓝帽子的号码之和 !=0" 和 "红帽子号码之和=蓝帽子的号码之和 =0"两种情况说明：

 1）若红帽子和蓝帽子的号码总和相等,均为0000（这种情况发生的概率为1/16，因为每一位加得为0的概率都是1/2，对别的位没有影响），
 那除了编上0000的人“不知所措”外，另外15个人都会选择猜，而且都会猜错，比如，编号为1001的人的人戴上了红帽子，
 他算得红帽子的总和为1001，蓝帽子的总和为0000，他会猜自己戴上了蓝帽子。

 2）若红帽子和蓝帽子的号码总和相等，且均不为0000，那只会有一个人选择猜，而且会猜对。
 如：红帽子和蓝帽子的号码总和均为0110，那么，编上0110的人若戴上红帽子，
 他算得红帽子的总和为0000，蓝帽子的总和为0110，他会猜自己戴红帽子，
 反之亦然。而别人都不会猜。

 综上，在这种方案下，犯人们的释放概率达到了15/16，也就是93.75%！

 不知道你发现没，
 在情况1）中，编上0000的人会不知所措，那是因为他算得红帽子和蓝帽子的号码总和均为0000，
 其实，他这个时候该知道自己死期临近了。
 而如果他看到红帽子和蓝帽子的号码总和均不为0000，那他也可以兴奋地知道自己被释放了。
 居然有一个人可以在随机事件中预知生死！

 ————这便是概率的魅力：有时候，它能让你变成能真正预知生死的巫师。
 */
class Hat{

    /**
     * 储存每个人的编号, 对于4个人的情况，依次从0000,0001,..., 1111
     */
    int bitNum[] = null;

    /**
     * 游戏中的人数,  必须为2的n次方。例如： 2,4,8,16,32, 等。
     */
    int num = 0;

    /**
     * 游戏中的人数,  必须为2的n次方。例如： 2,4,8,16,32, 等。
     * @param n
     */
    public Hat(int n){
        this.num = n>0?n:1;
        bitNum = new int[num];
        for(int i=0;i<num;i++){
            bitNum[i] = i;
        }

    }

    /**
     * 取得颜色为0的编号之和。
     * @param m
     * @return
     */
    private int getXORfromInt0(int m){
        int res = 0;
        for(int i=0;i<num;i++){
            int set = (m>>i)&0x1;
            if( set==0 ){
                res = res ^ bitNum[i];
            }
        }
        return res;
    }

    /**
     *
     * @return
     */
    public int getXOR0Frequency(){
        int sum = (1<<num);
        int f = 0;
        for(int i=0;i<sum;i++){
            if( getXORfromInt0(i) ==0 ){
                f++;
            }
        }
        return f;
    }
}